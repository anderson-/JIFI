/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package simulation.drawable;

import gui.QuickFrame;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.FocusListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelListener;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import static java.awt.image.ImageObserver.WIDTH;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JRootPane;
import javax.swing.JTextField;
import javax.swing.SwingUtilities;
import javax.swing.UnsupportedLookAndFeelException;
import simulation.drawable.DRobot;
import simulation.drawable.Drawable;
import simulation.drawable.Drawable.DynamicJComponent;
import util.Clock;
import util.ColorChanger;

/**
 *
 * @author antunes
 */
public class DrawingPanel extends JPanel implements KeyListener, MouseListener, MouseMotionListener, MouseWheelListener, ActionListener, ComponentListener {

    protected final long PAINT_DELAY = 2;
    protected final long NO_PAINT_DELAY = 100;
    private final ArrayList<Drawable> objects;
    private final ArrayList<Integer> keys;
    private final Point mouse;
    private Clock clock;
    private Thread repaintThread;
    private ListenerThread listenerThread;
    private BufferedImage buffer;
    private boolean repaint = false;
    private int width;
    private int height;
    private int globalX = 0, globalY = 0;
    private double zoom = 1.0;
    private boolean autoFullSize = false;
    private AffineTransform currentTransform;
    //********** comonente atal
    private AffineTransform tempTranform;
    private Drawable currentObject;
    private int objectX = 0;
    private int objectY = 0;
    private GraphicAttributes currentGraphicAtributes;
    private InputState currentInputState;
    public boolean test = false;

    public DrawingPanel(Clock c) {
        super(true);
        this.setPreferredSize(new Dimension(640, 480));
        this.setLayout(null);
        this.addMouseListener(this);
        this.addMouseMotionListener(this);
        this.addMouseWheelListener(this);

        mouse = new Point();
        clock = c;
        objects = new ArrayList<>();
        keys = new ArrayList<>();
        repaintThread = null;
        currentGraphicAtributes = new GraphicAttributes();
        currentInputState = new InputState();
        tempTranform = new AffineTransform();
        objects.add(new DrawableTest().appendTo(this));
        play();
    }

    public DrawingPanel(Clock c, boolean autoFullSize) {
        this(c);
        this.autoFullSize = autoFullSize;
    }

    protected final void createBuffers() {
        width = this.getWidth();
        height = this.getHeight();

        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice gs = ge.getDefaultScreenDevice();
        GraphicsConfiguration gc = gs.getDefaultConfiguration();

        buffer = gc.createCompatibleImage(width, height, Transparency.OPAQUE);
    }

    public DrawingPanel() {
        this(new Clock());
    }

    public final void play() {
        clock.setPaused(false);
        if (repaintThread == null) {
            repaintThread = new Thread("Repaint Thread " + Thread.activeCount()) {
                @Override
                public void run() {
                    try {
                        while (true) {
                            if (repaint) {
                                repaint();
                                Thread.sleep(PAINT_DELAY);
                            } else {
                                Thread.sleep(NO_PAINT_DELAY);
                            }
                        }
                    } catch (InterruptedException ex) {
                        repaintThread = null;
                    }
                }
            };
            repaintThread.start();
        }

        if (listenerThread == null) {
            listenerThread = new ListenerThread();
            listenerThread.start();
        }


        repaint = true;
    }

    public void pause() {
        repaint = false;
    }

    @Override
    protected void paintComponent(Graphics g) {
//        super.paintComponent(g); //não usar

        //ignora chamadas antes do buffer ser construido
        if (buffer == null) {
            return;
        }

        //desenha o fundo dentro do buffer
        Graphics g1 = buffer.getGraphics();
        g1.setColor(Color.WHITE);
        g1.fillRect(0, 0, width, height);

        //desenha o buffer no painel
        g.drawImage(buffer, 0, 0, null);

        //relogio global
        clock.increase();

        //converte Graphics para Graphics2D
        Graphics2D g2 = (Graphics2D) g;

        //deixa tudo lindo (antialiasing)
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        //aplica zoom e posição
        currentTransform = g2.getTransform();
        currentTransform.translate(globalX, globalY);
        currentTransform.scale(zoom, zoom);


        //desenha fundo
        synchronized (objects) {
            for (Drawable d : objects) {
                if (d.hasBackground()) {
                    tempTranform.setTransform(currentTransform);
                    tempTranform.translate(d.getX(), d.getY());
                    g2.setTransform(tempTranform);
                    d.drawBackground(g2, currentGraphicAtributes, currentInputState);
                }
            }
        }

        //desenha coisas
        synchronized (objects) {
            for (Drawable d : objects) {
                if (d.isVisible()) {
                    tempTranform.setTransform(currentTransform);
                    tempTranform.translate(d.getX(), d.getY());
                    g2.setTransform(tempTranform);
                    d.draw(g2, currentGraphicAtributes, currentInputState);
                }
            }
        }

        //desenha primeiro plano
        synchronized (objects) {
            for (Drawable d : objects) {
                if (d.hasTopLayer()) {
                    tempTranform.setTransform(currentTransform);
                    tempTranform.translate(d.getX(), d.getY());
                    g2.setTransform(tempTranform);
                    d.drawTop(g2, currentGraphicAtributes, currentInputState);
                }
            }
        }

        DrawingPanel.drawBallOrbitingCenter(g2, width, height);

        //reseta o zoom e posição para desenhar os componentes swing
        currentTransform.setToIdentity();
        g2.setTransform(currentTransform);

        //redefine o tamanho e a posição dos componentes swing
        synchronized (objects) {
            for (Drawable d : objects) {
                for (DynamicJComponent c : d) {
                    tempTranform.setTransform(currentTransform);
                    tempTranform.translate(d.getX(), d.getY());
                    //tempTranform.translate(.getX(), d.getY());
                    //define o tamanho do componente swing atual como
                    //o tamanho original do mesmo transformado pelo
                    //contexto atual
                    c.getComponent().setBounds(tempTranform.createTransformedShape(d.getShape()).getBounds());
                }
            }
        }
    }

    public static void drawBallOrbitingCenter(Graphics2D g, int width, int height) {
        double time = 2 * Math.PI * (System.currentTimeMillis() % 10000) / 10000.;
        g.setColor(Color.RED);
        g.fillOval((int) (Math.sin(time) * width / 3 + width / 2 - 20), (int) (Math.cos(time) * height / 3 + height / 2) - 20, 40, 40);
    }

    @Override
    public final void keyTyped(KeyEvent e) {
        synchronized (keys) {
            if (!keys.contains(e.getKeyCode())) {
                keys.add(e.getKeyCode());
            }
        }
    }

    @Override
    public final void keyPressed(KeyEvent e) {
        synchronized (keys) {
            if (!keys.contains(e.getKeyCode())) {
                keys.add(e.getKeyCode());
            }
        }
    }

    @Override
    public final void keyReleased(KeyEvent e) {
        synchronized (keys) {
            if (!keys.contains(e.getKeyCode())) {
                keys.add(e.getKeyCode());
            }
        }
    }

    public void keys(List<Integer> keys) {
    }

    @Override
    public void mouseClicked(final MouseEvent e) {
        new Pew(e.getX(), e.getY()).start();
//        try {
//            Thread.sleep(2000);
//        } catch (InterruptedException ex) {
//        }
    }

    @Override
    public void mousePressed(MouseEvent e) {
    }

    @Override
    public void mouseReleased(MouseEvent e) {
    }

    @Override
    public void mouseEntered(MouseEvent e) {
    }

    @Override
    public void mouseExited(MouseEvent e) {
    }

    @Override
    public void mouseDragged(MouseEvent e) {


//        int b1 = MouseEvent.BUTTON1_DOWN_MASK;
//        if ((e.getModifiersEx() & b1) == b1) {
//            Rectangle r = jCompBounds.get(0);
//            r.setLocation(getMouse(mouse));
//            jCompBounds.set(0, r);
//        } else {
//            //define a posição relativa com base no deslocamento do mouse
//            //**usar obviamente antes de redefinir mouse**
//            
//            jComponents.get(0).setVisible(test);
//            test = !test;
//        }

        synchronized (mouse) {
            //define a posição relativa com base no deslocamento do mouse
            setPosition((int) (mouse.getX() - e.getPoint().getX()), (int) (mouse.getY() - e.getPoint().getY()));
            mouse.setLocation(e.getPoint());
        }
    }

    @Override
    public void mouseMoved(MouseEvent e) {
        synchronized (mouse) {
            mouse.setLocation(e.getPoint());
        }
    }

    @Override
    public void mouseWheelMoved(MouseWheelEvent e) {
        setZoom(e.getWheelRotation() * 0.1, e.getPoint());
    }

    @Override
    public void actionPerformed(ActionEvent e) {
//        this.repaint();
    }

    @Override
    public void componentResized(ComponentEvent e) {
        if (autoFullSize) {
            width = e.getComponent().getWidth();
            height = e.getComponent().getHeight();
            this.setSize(width, height);
        }
        createBuffers();
    }

    @Override
    public void componentMoved(ComponentEvent e) {
    }

    @Override
    public void componentShown(ComponentEvent e) {
    }

    @Override
    public void componentHidden(ComponentEvent e) {
    }

    public synchronized void setZoom(double z, Point pos) {
        if ((zoom + z) > 0.1) {

            Point posInside = getMouse(pos);

            if (new Rectangle(0, 0, width, height).contains(posInside)) {
                globalX -= (int) (((pos.getX() - globalX) / zoom) * z);
                globalY -= (int) (((pos.getY() - globalY) / zoom) * z);
            } else {
                globalX -= (int) (width * z / 2.0);
                globalY -= (int) (height * z / 2.0);
            }

            zoom = zoom + z;
        }
    }

    public synchronized double getZoom() {
        return zoom;
    }

    public synchronized Point getPosition() {
        return new Point(globalX, globalY);
    }

    public synchronized void setPosition(int x, int y) {
        globalX -= x;
        globalY -= y;
    }

    public synchronized void center(Rectangle clip) {
        globalX = (int) (clip.width * zoom / 2.0 - width * zoom / 2.0);
        globalY = (int) (clip.height * zoom / 2.0 - height * zoom / 2.0);
    }

    public synchronized Point getMouse(Point mouse) {
        return new Point((int) ((mouse.getX() - globalX) / zoom), (int) ((mouse.getY() - globalY) / zoom));
    }

    public static void drawGrade(Graphics2D g, int grid, float p, Rectangle bounds) {
        if (grid > 0) {

            int prop = (int) p / grid;

            for (int x = -(bounds.width / prop) / 2; x <= (bounds.width / prop) / 2; x++) {
                g.drawLine(x * prop, -bounds.height / 2, x * prop, bounds.height / 2);
            }

            for (int y = -(bounds.height / prop) / 2; y <= (bounds.height / prop) / 2; y++) {
                g.drawLine(-bounds.width / 2, y * prop, bounds.width / 2, y * prop);
            }

        } else if (grid < 0) {
            int prop = (int) p / -grid;

            for (int x = -(bounds.width / prop) / 2; x <= (bounds.width / prop) / 2; x++) {
                for (int y = -(bounds.height / prop) / 2; y <= (bounds.height / prop) / 2; y++) {
                    g.fillRect(x * prop - 1, y * prop - 1, 2, 2);
                }
            }

        } else {
            return;
        }
        String str = "grade: " + Math.abs(1.0f / grid) * 100 + " cm";
        int sx = g.getFontMetrics().stringWidth(str);
        int sy = g.getFontMetrics().getHeight();
        int px = bounds.width / 2 - 10 - sx;
        int py = bounds.height / 2 - 20;
        g.setColor(Color.lightGray);
        g.fillRect(px, py - 11, sx, sy);
        g.setColor(Color.white);
        g.drawString(str, px, py);

    }

    public class GraphicAttributes {

        private GraphicAttributes() {
        }

        public Clock getClock() {
            return clock;
        }

        public void applyZoom(AffineTransform t) {
            t.scale(zoom, zoom);
        }

        public void removeZoom(AffineTransform t) {
            t.scale(1 / zoom, 1 / zoom);
        }

        public void applyGlobalPosition(AffineTransform t) {
            t.translate(globalX, globalY);
        }

        public void removeGlobalPosition(AffineTransform t) {
            t.translate(-globalX, -globalY);
        }

        public void reset(AffineTransform t) {
            t.setToIdentity();
            t.translate(objectX, objectY);
        }
    }

    public class InputState {

        private InputState() {
        }

        public boolean isKeyPressed(int key) {
            synchronized (keys) {
                return keys.contains(key);
            }
        }

        public boolean isMouseOver() {
            synchronized (mouse) {
                return currentObject.getShape().contains(mouse);
            }
        }

        public Point getMouse() {
            synchronized (mouse) {
                return new Point(mouse);//mudar para posição relativa?
            }
        }
    }

    private class ListenerThread extends Thread {

        private boolean run = true;
        private Point mouseCpy = new Point();
        private ArrayList<Integer> keysCpy = new ArrayList<>();

        public ListenerThread() {
        }

        @Override
        public void run() {
            try {
                while (true) {
                    if (run) {
                        synchronized (mouse) {
                            mouseCpy.setLocation(mouse);
                        }
                        keysCpy.clear();
                        synchronized (keys) {
                            keysCpy.addAll(keys);
                        }

                        Drawable.GeneralListener gl;
                        synchronized (objects) {
                            for (Drawable d : objects) {
                                if (d instanceof Drawable.GeneralListener) {
                                    gl = (Drawable.GeneralListener) d;

                                }
                            }
                        }

                        if (!keys.isEmpty()) {
                            keys(keys);
                        }

                        Thread.sleep(PAINT_DELAY);
                    } else {
                        Thread.sleep(NO_PAINT_DELAY);
                    }
                }
            } catch (InterruptedException ex) {
                listenerThread = null;
            }
        }
    }

    public static void main(String[] args) {
        try {
            javax.swing.UIManager.setLookAndFeel(javax.swing.UIManager.getSystemLookAndFeelClassName());
        } catch (ClassNotFoundException ex) {
        } catch (InstantiationException ex) {
        } catch (IllegalAccessException ex) {
        } catch (UnsupportedLookAndFeelException ex) {
        }

        final DrawingPanel p = new DrawingPanel();
        final JFrame f = QuickFrame.create(p, "Teste");
        f.addComponentListener(p);

//        final JPanel panel = new JPanel();
        final JPanel panel = new JPanel() {
            @Override
            public void repaint() {
                JRootPane rootPane = SwingUtilities.getRootPane(this);
                if (rootPane != null) {
                    JPanel contentPane = (JPanel) rootPane.getContentPane();
                    contentPane.repaint();
                }
            }
        };
        panel.setBackground(Color.magenta);
        JButton jb = new JButton("test");
//        jb.setEnabled(false);
        //jb.setBounds(300, 300, 20, 20);


//        p.addSwing(jb, new Rectangle(300, 300, 80, 40));
        panel.setPreferredSize(new Dimension(100, 100));



        DrawingPanel pInner = new DrawingPanel();
        pInner.setBounds(0, 100, 200, 200);
        pInner.setSize(200, 200);
//        pInner.test = true;
        f.addComponentListener(pInner);
//        pInner.createBuffers();
        p.add(pInner);

        panel.setBounds(20, 150, 200, 200);
        panel.setSize(200, 200);
        p.add(panel);

//        p.createBuffers();
    }

    public class Pew extends Thread {

        JTextField field = new JTextField("pew!");
        double x, y;

        public Pew(int x, int y) {
            this.x = x;
            this.y = y;
            add(field);
        }

        public void run() {
            while (true) {
                field.setBounds(new Rectangle((int) x, (int) y, 100, 20));
                x += Math.random() - 0.5;
                y += Math.random() - 0.5;
                try {
                    Thread.sleep(10);
                } catch (Exception e) {
                }
            }
        }
    }
}
